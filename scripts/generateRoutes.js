import fs from 'fs';
import path from 'path';

const root = path.resolve(path.dirname(new URL(import.meta.url).pathname), '..');
const pagesDir = path.join(root, 'src/pages');
const outFile = path.join(root, 'src/routes.generated.ts');

function toKebabCase(str) {
  return str
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/_/g, '-')
    .toLowerCase();
}

function walk(dir, segments = [], routes = []) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.name.startsWith('_') || entry.name.startsWith('.')) continue;
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      walk(full, [...segments, entry.name], routes);
    } else if (/\.(tsx|ts|jsx|js)$/.test(entry.name)) {
      const name = entry.name.replace(/\.(tsx|ts|jsx|js)$/i, '');
      const routeSegments = [...segments, name].map(toKebabCase);
      const routePath = '/dashboard/' + routeSegments.join('/');
      const rel = path
        .relative(path.join(root, 'src'), full)
        .replace(/\.(tsx|ts|jsx|js)$/i, '')
        .split(path.sep)
        .join('/');
      const importPath = `@/${rel}`;
      routes.push({ path: routePath, component: importPath });
    }
  }
  return routes;
}

export function generateRoutes() {
  const routes = walk(pagesDir);
  const content = `// This file is auto-generated by scripts/generateRoutes.js\n` +
    `export interface GeneratedRoute { path: string; component: string }\n` +
    `export const generatedRoutes: GeneratedRoute[] = ${JSON.stringify(routes, null, 2)}\n`;
  fs.writeFileSync(outFile, content);
}

export default function generateRoutesPlugin() {
  return {
    name: 'generate-routes-plugin',
    buildStart() {
      generateRoutes();
    }
  };
}

if (import.meta.url === `file://${process.argv[1]}`) {
  generateRoutes();
}
